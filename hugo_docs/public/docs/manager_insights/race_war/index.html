<!DOCTYPE html>
<html lang="en-us" dir="ltr">
    <head><script src="/agentic/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=agentic/livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="Next Episode: For The Greater Good The goal was simple: a stable, high-concurrency streaming chatbot. The reality was a series of cascading failures rooted in the subtle complexities of Go&rsquo;s concurrency model. This document details the problems we faced, from the obvious memory leaks to the treacherous race conditions that followed, and the specific architectural changes in manager.go and streamer.go that were required to achieve true stability. Problem #1 - The Zombie Apocalypse (The Original Goroutine Leak) Symptom: The server&rsquo;s memory usage would climb relentlessly over time, especially under load, leading to an inevitable crash.">
<title>A War Against Race Conditions</title>

<link rel='canonical' href='http://localhost:1313/agentic/docs/manager_insights/race_war/'>

<link rel="stylesheet" href="/agentic/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="A War Against Race Conditions">
<meta property='og:description' content="Next Episode: For The Greater Good The goal was simple: a stable, high-concurrency streaming chatbot. The reality was a series of cascading failures rooted in the subtle complexities of Go&rsquo;s concurrency model. This document details the problems we faced, from the obvious memory leaks to the treacherous race conditions that followed, and the specific architectural changes in manager.go and streamer.go that were required to achieve true stability. Problem #1 - The Zombie Apocalypse (The Original Goroutine Leak) Symptom: The server&rsquo;s memory usage would climb relentlessly over time, especially under load, leading to an inevitable crash.">
<meta property='og:url' content='http://localhost:1313/agentic/docs/manager_insights/race_war/'>
<meta property='og:site_name' content='Go Chatbot'>
<meta property='og:type' content='article'><meta property='article:section' content='Docs' /><meta property='article:published_time' content='2025-08-02T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2025-08-02T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="A War Against Race Conditions">
<meta name="twitter:description" content="Next Episode: For The Greater Good The goal was simple: a stable, high-concurrency streaming chatbot. The reality was a series of cascading failures rooted in the subtle complexities of Go&rsquo;s concurrency model. This document details the problems we faced, from the obvious memory leaks to the treacherous race conditions that followed, and the specific architectural changes in manager.go and streamer.go that were required to achieve true stability. Problem #1 - The Zombie Apocalypse (The Original Goroutine Leak) Symptom: The server&rsquo;s memory usage would climb relentlessly over time, especially under load, leading to an inevitable crash.">
    <link rel="shortcut icon" href="/agentic/favicon.png" />

    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column compact"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/agentic/">
                
                    
                    
                    
                        
                        <img src="/agentic/img/penguin_hu985367dcd5439c3a63e69853053effce_25187_300x0_resize_box_3.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">ðŸ¤–</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/agentic">Go Chatbot</a></h1>
            <h2 class="site-description">Documentation</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/miftahulmahfuzh/agentic'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/agentic/' >
                
                
                
                <span>Home</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>Dark Mode</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    

            <main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/agentic/docs/manager_insights/race_war/">A War Against Race Conditions</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Aug 02, 2025</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    6 minute read
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p><strong>Next Episode:</strong> <a class="link" href="https://miftahulmahfuzh.github.io/agentic/docs/architectures/bigger_picture"  target="_blank" rel="noopener"
    >For The Greater Good</a></p>
<p>The goal was simple: a stable, high-concurrency streaming chatbot. The reality was a series of cascading failures rooted in the subtle complexities of Go&rsquo;s concurrency model. This document details the problems we faced, from the obvious memory leaks to the treacherous race conditions that followed, and the specific architectural changes in <code>manager.go</code> and <code>streamer.go</code> that were required to achieve true stability.</p>
<hr>
<h3 id="problem-1---the-zombie-apocalypse-the-original-goroutine-leak">Problem #1 - The Zombie Apocalypse (The Original Goroutine Leak)
</h3><p><strong>Symptom:</strong> The server&rsquo;s memory usage would climb relentlessly over time, especially under load, leading to an inevitable crash.</p>
<p><strong>Root Cause: The &ldquo;Stuck Writer&rdquo; Flaw.</strong>
The original <code>streamer.go</code> had a fatal flaw. Writing to a Go channel (<code>streamChan &lt;- event</code>) is a <strong>blocking operation</strong>. The writer goroutine will freeze until a reader is ready. When a client disconnected, the reading part of the code in <code>handleStreamRequest</code> would terminate. However, the worker goroutine was left frozen mid-write, waiting for a reader that would never come.</p>
<p>This created a <strong>zombie goroutine</strong>: a process that was still alive, holding memory, but would never complete. Every disconnected client created another zombie, leading to a slow, inevitable memory leak.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6272a4">// OLD STREAMER.GO - The source of the leak
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// If the client disconnects, the goroutine running this code
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4">// freezes here forever, leaking its memory and resources.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>streamChan <span style="color:#ff79c6">&lt;-</span> tooltypes.StreamEvent{Type: tooltypes.StreamEventToken, Payload: <span style="color:#8be9fd;font-style:italic">string</span>(chunk)}
</span></span></code></pre></div><p><strong>Solution: The Context-Aware Escape Hatch (<code>sendEvent</code>).</strong>
The fix was to make the write operation &ldquo;cancellation-aware&rdquo; by using the request&rsquo;s <code>context</code>. We introduced a helper function, <code>sendEvent</code>, that uses a <code>select</code> statement.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6272a4">// NEW STREAMER.GO - The initial fix
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s <span style="color:#ff79c6">*</span>ResponseStreamer) <span style="color:#50fa7b">sendEvent</span>(ctx context.Context, streamChan <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> tooltypes.StreamEvent, event tooltypes.StreamEvent) <span style="color:#8be9fd">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">case</span> <span style="color:#ff79c6">&lt;-</span>ctx.<span style="color:#50fa7b">Done</span>(): <span style="color:#6272a4">// If the context is cancelled...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">return</span> ctx.<span style="color:#50fa7b">Err</span>() <span style="color:#6272a4">// ...abort the write and return an error.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">case</span> streamChan <span style="color:#ff79c6">&lt;-</span> event: <span style="color:#6272a4">// Otherwise, proceed with the write.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>		<span style="color:#ff79c6">return</span> <span style="color:#ff79c6">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now, when a client disconnects, the manager cancels the request&rsquo;s context. The <code>sendEvent</code> function sees <code>&lt;-ctx.Done()</code> become ready, aborts the write, and allows the goroutine to shut down gracefully, releasing its memory.</p>
<p><strong>This solved the memory leak but, like a Faustian bargain, created two new, more insidious race conditions.</strong></p>
<hr>
<h3 id="problem-2---the-pre-emptive-cleanup-the-keyser-sÃ¶ze-problem">Problem #2 - The Pre-emptive Cleanup (The Keyser SÃ¶ze Problem)
</h3><p><strong>Symptom:</strong> A client calls <code>/cancel</code> on a request and <em>then</em> calls <code>/stream</code> to get the final cancellation confirmation. Instead of the expected <code>{&quot;status&quot;:&quot;cancelled&quot;}</code> message, they receive a &ldquo;request not found&rdquo; error. The request had vanished.</p>
<p><strong>Root Cause: Overly Aggressive Cleanup.</strong>
Our new cancellation mechanism was too effective. Here&rsquo;s the race:</p>
<ol>
<li><code>CancelStream</code> is called. It correctly marks the request as <code>StateCancelled</code> and triggers the context cancellation.</li>
<li>The worker goroutine, which has a <code>defer m.cleanupRequest(...)</code> statement, immediately sees the cancelled context and exits.</li>
<li>The deferred <code>cleanupRequest</code> runs, completely wiping all trace of the request from the <code>activeRequests</code> map. It&rsquo;s a ghost.</li>
<li>The client, a moment later, calls <code>/stream</code> to get the final status, but the request record is already gone.</li>
</ol>
<p><strong>Solution: Conditional, Responsible Cleanup in <code>manager.go</code>.</strong>
The worker goroutine needed to be taught some discretion. It cannot clean up a request that was explicitly cancelled by the user, because that request is waiting to deliver a &ldquo;pre-canned&rdquo; cancellation message.</p>
<p>The fix was to make the worker&rsquo;s deferred cleanup conditional. It now checks the state of the request before acting.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6272a4">// chatbot/manager.go - The fix in streamWorkerManager&#39;s defer block
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#ff79c6">defer</span> <span style="color:#8be9fd;font-style:italic">func</span>() {
</span></span><span style="display:flex;"><span>    m.requestsLock.<span style="color:#50fa7b">RLock</span>()
</span></span><span style="display:flex;"><span>    h, h_ok <span style="color:#ff79c6">:=</span> m.activeRequests[reqID]
</span></span><span style="display:flex;"><span>    m.requestsLock.<span style="color:#50fa7b">RUnlock</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// If the request was explicitly cancelled, it&#39;s not our job to clean up.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#6272a4">// We yield responsibility to the newCancelledStream flow.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    <span style="color:#ff79c6">if</span> h_ok <span style="color:#ff79c6">&amp;&amp;</span> h.State <span style="color:#ff79c6">==</span> types.StateCancelled {
</span></span><span style="display:flex;"><span>        logCtx.<span style="color:#50fa7b">Info</span>().<span style="color:#50fa7b">Msg</span>(<span style="color:#f1fa8c">&#34;Request was cancelled. Worker is yielding cleanup responsibility.&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#ff79c6">return</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// Otherwise, proceed with normal timeout-based cleanup.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>    m.<span style="color:#50fa7b">cleanupRequest</span>(reqID, logCtx)
</span></span><span style="display:flex;"><span>}()
</span></span></code></pre></div><p>The worker now yields cleanup duty for <code>StateCancelled</code> requests, ensuring the record stays alive long enough for <code>GetRequestResultStream</code> to find it and serve the proper confirmation.</p>
<hr>
<h3 id="problem-3---the-muted-messenger-the-hasta-la-vista-paradox">Problem #3 - The Muted Messenger (The &ldquo;Hasta la Vista&rdquo; Paradox)
</h3><p><strong>Symptom:</strong> A client calls <code>/cancel</code> <em>during</em> an active stream. The stream stops, but the connection simply closes. The final, crucial <code>{&quot;status&quot;:&quot;cancelled&quot;}</code> message is never received.</p>
<p><strong>Root Cause: A Logical Paradox.</strong>
This was the most subtle problem.</p>
<ol>
<li><code>/cancel</code> is called mid-stream, and the context is cancelled.</li>
<li>The <code>streamer</code>, using our robust <code>sendEvent</code> function, detects the cancelled context on its next token-send attempt and correctly returns a <code>context.Canceled</code> error.</li>
<li>The error handling logic (<code>handleLLMStreamError</code>) catches this error and attempts to send the final cancellation message to the client.</li>
<li><strong>The Paradox:</strong> To send this final message, it uses a function that relies on <code>sendEvent</code>. But <code>sendEvent</code> is designed to <em>immediately fail</em> if the context is cancelled. It was doing its job perfectly, which prevented it from delivering the final word. The system was trying to shout a message through a phone line it had just proudly cut.</li>
</ol>
<p><strong>Solution: The &ldquo;Last Gasp&rdquo; Write in <code>streamer.go</code>.</strong>
For this one specific scenario, we needed a function that would attempt one final, non-blocking, fire-and-forget write that <em>ignores</em> the context.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#6272a4">// chatbot/streamer.go - The &#34;Last Gasp&#34; helper
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span><span style="color:#8be9fd;font-style:italic">func</span> (s <span style="color:#ff79c6">*</span>ResponseStreamer) <span style="color:#50fa7b">sendLastGaspTerminalInfo</span>(streamChan <span style="color:#8be9fd;font-style:italic">chan</span><span style="color:#ff79c6">&lt;-</span> tooltypes.StreamEvent, message <span style="color:#8be9fd">string</span>, status types.CompletionStatus) {
</span></span><span style="display:flex;"><span>    <span style="color:#6272a4">// ... create event ...
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff79c6">case</span> streamChan <span style="color:#ff79c6">&lt;-</span> event:
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// We tried, and it worked. Good.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	<span style="color:#ff79c6">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#6272a4">// The client is already gone. The channel is blocked. We don&#39;t care. Abort.
</span></span></span><span style="display:flex;"><span><span style="color:#6272a4"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This function is called <em>only</em> when a <code>context.Canceled</code> error is detected in the streaming logic. It makes one best-effort attempt to send the final status. If the client is still connected for that microsecond, they get the message. If not, the function returns instantly without blocking, preventing any new leaks.</p>
<h3 id="summary-the-war-report">Summary: The War Report
</h3><div class="table-wrapper"><table>
<thead>
<tr>
<th style="text-align:left">Problem</th>
<th style="text-align:left">Symptom</th>
<th style="text-align:left">Root Cause</th>
<th style="text-align:left">Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>#1: The Zombie Apocalypse</strong></td>
<td style="text-align:left">Steadily increasing memory usage, leading to server crashes.</td>
<td style="text-align:left"><strong>&ldquo;Stuck Writer&rdquo;:</strong> A goroutine blocks forever on a channel write to a disconnected client.</td>
<td style="text-align:left"><strong>Context-Aware Writes:</strong> Use <code>select</code> with <code>&lt;-ctx.Done()</code> in a <code>sendEvent</code> helper to provide an escape hatch, allowing the goroutine to terminate gracefully.</td>
</tr>
<tr>
<td style="text-align:left"><strong>#2: The Pre-emptive Cleanup</strong></td>
<td style="text-align:left">Calling <code>/cancel</code> then <code>/stream</code> results in a &ldquo;not found&rdquo; error, not a cancellation message.</td>
<td style="text-align:left"><strong>&ldquo;Overly Aggressive Cleanup&rdquo;:</strong> The worker&rsquo;s <code>defer</code> statement cleans up the request record before the client can poll for the final status.</td>
<td style="text-align:left"><strong>Conditional Cleanup (<code>manager.go</code>):</strong> The worker&rsquo;s <code>defer</code> now checks the request state. If <code>StateCancelled</code>, it yields cleanup responsibility, keeping the record alive.</td>
</tr>
<tr>
<td style="text-align:left"><strong>#3: The Muted Messenger</strong></td>
<td style="text-align:left">Calling <code>/cancel</code> mid-stream closes the connection without a final confirmation message.</td>
<td style="text-align:left"><strong>&ldquo;The Cancellation Paradox&rdquo;:</strong> The mechanism to detect cancellation (<code>sendEvent</code>) also prevents sending the final cancellation message.</td>
<td style="text-align:left"><strong>&ldquo;Last Gasp&rdquo; Write (<code>streamer.go</code>):</strong> A special, non-blocking, fire-and-forget send function is used <em>only</em> for this case, making one final attempt to deliver the message.</td>
</tr>
</tbody>
</table></div>

</section>


    <footer class="article-footer">
    

    </footer>


    
</article>

    

    

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2024 - 
        
        2025 Go Chatbot
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.30.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/agentic/ts/main.7d3b06a3f9c7fc3f9e8edd384e9d4245f05cc3d94e687961eee37c1b5c98d939.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
